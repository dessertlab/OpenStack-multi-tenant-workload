
import random, binascii, threading, os, time

def pycc_corrupt_string(string):
    if string:
        if (random.randint(0, 1) == 0):
            hexstring = binascii.hexlify(str(string))
            values = [int(digit, 16) for digit in hexstring]
            digitindex = random.randint(0, len(values))
            bitindex = random.randint(0, 3)
            values[(digitindex - 1)] ^= (1 << bitindex)
            result = ''.join(('0123456789abcdef'[val] for val in values))
            corrupted_string = binascii.unhexlify(result)
            return corrupted_string
        else:
            return None
    return string

def pycc_corrupt_dict_key(d):
    if d:
        old_key = random.choice(d.keys())
        corrupted_key = pycc_corrupt(old_key)
        d[corrupted_key] = d.pop(old_key)
    return d

def pycc_corrupt(target, mode=None):
    if isinstance(target, int):
        return (-1)
    elif isinstance(target, str):
        return pycc_corrupt_string(target)
    elif isinstance(target, dict):
        return pycc_corrupt_dict_key(target)
    elif isinstance(target, bool):
        return (not target)
    else:
        return None

def pycc_sleep(milliseconds):
    time.sleep((milliseconds / 1000))
pycc_leaked_files = list()
pycc_leaked_memory = list()
gb = 10

def _pycc_hog_fd():
    try:
        i = 0
        files = []
        pycc_leak_file_dir = '/tmp/pycc_file_leak_dir/'
        os.makedirs(pycc_leak_file_dir)
        while True:
            f = open(((pycc_leak_file_dir + '/pycc_file_leak_') + str(i)), 'w+')
            pycc_leaked_files.append(f)
            i = (i + 1)
    except:
        pass

def _pycc_hog_cpu():
    while True:
        for i in range(100):
            (i * i)

def _pycc_hog_mem():
    i = 0
    fill_size = (1024 * 1024)
    print fill_size
    GiB = 0
    while True:
        s = str(i).zfill(fill_size)
        pycc_leaked_memory.append(s)
        i += 1
        if ((i % 1024) == 0):
            GiB += 1
            if (GiB >= gb):
                return

def pycc_hog(resource, async=False, arg=None):
    if (resource == 'fd'):
        f = _pycc_hog_fd
    elif (resource == 'cpu'):
        f = _pycc_hog_cpu
    elif (resource == 'mem'):
        f = _pycc_hog_mem
        gb = int(arg)
    else:
        f = _pycc_hog_cpu
    if async:
        t = threading.Thread(target=f)
        t.start()
    else:
        f()
import copy
import functools
import re
import time
from keystoneauth1 import exceptions as ks_exc
from keystoneauth1 import loading as keystone
from oslo_log import log as logging
from six.moves.urllib import parse
from nova.compute import utils as compute_utils
import nova.conf
from nova import exception
from nova.i18n import _LE, _LI, _LW
from nova import objects
from nova.objects import fields
from nova.scheduler import utils as scheduler_utils
CONF = nova.conf.CONF
LOG = logging.getLogger(__name__)
VCPU = fields.ResourceClass.VCPU
MEMORY_MB = fields.ResourceClass.MEMORY_MB
DISK_GB = fields.ResourceClass.DISK_GB
_RE_INV_IN_USE = re.compile('Inventory for (.+) on resource provider (.+) in use')
WARN_EVERY = 10

def warn_limit(self, msg):
    if self._warn_count:
        self._warn_count -= 1
    else:
        self._warn_count = WARN_EVERY
        LOG.warning(msg)

def safe_connect(f):

    @functools.wraps(f)
    def wrapper(self, *a, **k):
        try:
            return f(self, *a, **k)
        except ks_exc.EndpointNotFound:
            warn_limit(self, _LW('The placement API endpoint not found. Placement is optional in Newton, but required in Ocata. Please enable the placement service before upgrading.'))
        except ks_exc.MissingAuthPlugin:
            warn_limit(self, _LW('No authentication information found for placement API. Placement is optional in Newton, but required in Ocata. Please enable the placement service before upgrading.'))
        except ks_exc.Unauthorized:
            warn_limit(self, _LW('Placement service credentials do not work. Placement is optional in Newton, but required in Ocata. Please enable the placement service before upgrading.'))
        except ks_exc.DiscoveryFailure:
            warn_limit(self, _LW('Discovering suitable URL for placement API failed.'))
        except ks_exc.ConnectFailure:
            msg = _LW('Placement API service is not responding.')
            LOG.warning(msg)
    return wrapper

def _compute_node_to_inventory_dict(compute_node):
    'Given a supplied `objects.ComputeNode` object, return a dict, keyed\n    by resource class, of various inventory information.\n\n    :param compute_node: `objects.ComputeNode` object to translate\n    '
    result = {}
    if (compute_node.vcpus > 0):
        result[VCPU] = {'total': compute_node.vcpus, 'reserved': CONF.reserved_host_cpus, 'min_unit': 1, 'max_unit': compute_node.vcpus, 'step_size': 1, 'allocation_ratio': compute_node.cpu_allocation_ratio}
    if (compute_node.memory_mb > 0):
        result[MEMORY_MB] = {'total': compute_node.memory_mb, 'reserved': CONF.reserved_host_memory_mb, 'min_unit': 1, 'max_unit': compute_node.memory_mb, 'step_size': 1, 'allocation_ratio': compute_node.ram_allocation_ratio}
    if (compute_node.local_gb > 0):
        reserved_disk_gb = compute_utils.convert_mb_to_ceil_gb(CONF.reserved_host_disk_mb)
        result[DISK_GB] = {'total': compute_node.local_gb, 'reserved': reserved_disk_gb, 'min_unit': 1, 'max_unit': compute_node.local_gb, 'step_size': 1, 'allocation_ratio': compute_node.disk_allocation_ratio}
    return result

def _instance_to_allocations_dict(instance):
    'Given an `objects.Instance` object, return a dict, keyed by resource\n    class of the amount used by the instance.\n\n    :param instance: `objects.Instance` object to translate\n    '
    alloc_dict = scheduler_utils.resources_from_flavor(instance, instance.flavor)
    return {key: val for (key, val) in alloc_dict.items() if val}

def _move_operation_alloc_request(source_allocs, dest_alloc_req):
    'Given existing allocations for a source host and a new allocation\n    request for a destination host, return a new allocation request that\n    contains resources claimed against both source and destination, accounting\n    for shared providers.\n\n    Also accounts for a resize to the same host where the source and dest\n    compute node resource providers are going to be the same. In that case\n    we sum the resource allocations for the single provider.\n\n    :param source_allocs: Dict, keyed by resource provider UUID, of resources\n                          allocated on the source host\n    :param dest_alloc_request: The allocation request for resources against the\n                               destination host\n    '
    LOG.debug('Doubling-up allocation request for move operation.')
    cur_rp_uuids = set(source_allocs.keys())
    new_rp_uuids = (set((a['resource_provider']['uuid'] for a in dest_alloc_req['allocations'])) - cur_rp_uuids)
    current_allocs = [{'resource_provider': {'uuid': cur_rp_uuid}, 'resources': alloc['resources']} for (cur_rp_uuid, alloc) in source_allocs.items()]
    new_alloc_req = {'allocations': current_allocs}
    for alloc in dest_alloc_req['allocations']:
        if (alloc['resource_provider']['uuid'] in new_rp_uuids):
            new_alloc_req['allocations'].append(alloc)
        elif (not new_rp_uuids):
            for current_alloc in current_allocs:
                if (current_alloc['resource_provider']['uuid'] == alloc['resource_provider']['uuid']):
                    scheduler_utils.merge_resources(current_alloc['resources'], alloc['resources'])
    LOG.debug('New allocation request containing both source and destination hosts in move operation: %s', new_alloc_req)
    return new_alloc_req

def _extract_inventory_in_use(body):
    'Given an HTTP response body, extract the resource classes that were\n    still in use when we tried to delete inventory.\n\n    :returns: String of resource classes or None if there was no InventoryInUse\n              error in the response body.\n    '
    match = _RE_INV_IN_USE.search(body)
    if match:
        return match.group(1)
    return None

def get_placement_request_id(response):
    if (response is not None):
        return response.headers.get('openstack-request-id', response.headers.get('x-openstack-request-id'))

class SchedulerReportClient(object, ):
    'Client class for updating the scheduler.'

    def __init__(self):
        self._resource_providers = {}
        self._provider_aggregate_map = {}
        auth_plugin = keystone.load_auth_from_conf_options(CONF, 'placement')
        self._client = keystone.load_session_from_conf_options(CONF, 'placement', auth=auth_plugin)
        self._warn_count = 0
        self.ks_filter = {'service_type': 'placement', 'region_name': CONF.placement.os_region_name, 'interface': CONF.placement.os_interface}

    def get(self, url, version=None):
        kwargs = {}
        if (version is not None):
            kwargs = {'headers': {'OpenStack-API-Version': ('placement %s' % version)}}
        return self._client.get(url, endpoint_filter=self.ks_filter, raise_exc=False, **kwargs)

    def post(self, url, data, version=None):
        kwargs = {}
        if (version is not None):
            kwargs = {'headers': {'OpenStack-API-Version': ('placement %s' % version)}}
        return self._client.post(url, json=data, endpoint_filter=self.ks_filter, raise_exc=False, **kwargs)

    def put(self, url, data, version=None):
        kwargs = {}
        if (version is not None):
            kwargs = {'headers': {'OpenStack-API-Version': ('placement %s' % version)}}
        if data:
            kwargs['json'] = data
        return self._client.put(url, endpoint_filter=self.ks_filter, raise_exc=False, **kwargs)

    def delete(self, url, version=None):
        kwargs = {}
        if (version is not None):
            kwargs = {'headers': {'OpenStack-API-Version': ('placement %s' % version)}}
        return self._client.delete(url, endpoint_filter=self.ks_filter, raise_exc=False, **kwargs)

    @safe_connect
    def get_allocation_candidates(self, resources):
        'Returns a tuple of (allocation_requests, provider_summaries).\n\n        The allocation requests are a collection of potential JSON objects that\n        can be passed to the PUT /allocations/{consumer_uuid} Placement REST\n        API to claim resources against one or more resource providers that meet\n        the requested resource constraints.\n\n        The provider summaries is a dict, keyed by resource provider UUID, of\n        inventory and capacity information for any resource provider involved\n        in the allocation requests.\n\n        :returns: A tuple with a list of allocation request dicts and a dict of\n                  provider information or (None, None) if the request failed\n\n        :param resources: A dict, keyed by resource class name, of requested\n                          amounts of those resources\n        '
        resource_query = ','.join(sorted((('%s:%s' % (rc, amount)) for (rc, amount) in resources.items())))
        qs_params = {'resources': resource_query}
        url = ('/allocation_candidates?%s' % parse.urlencode(qs_params))
        resp = self.get(url, version='1.10')
        if (resp.status_code == 200):
            data = resp.json()
            return (data['allocation_requests'], data['provider_summaries'])
        msg = 'Failed to retrieve allocation candidates from placement API for filters %(resources)s. Got %(status_code)d: %(err_text)s.'
        args = {'resources': resources, 'status_code': resp.status_code, 'err_text': resp.text}
        LOG.error(msg, args)
        return (None, None)

    @safe_connect
    def _get_provider_aggregates(self, rp_uuid):
        "Queries the placement API for a resource provider's aggregates.\n        Returns a set() of aggregate UUIDs or None if no such resource provider\n        was found or there was an error communicating with the placement API.\n\n        :param rp_uuid: UUID of the resource provider to grab aggregates for.\n        "
        resp = self.get(('/resource_providers/%s/aggregates' % rp_uuid), version='1.1')
        if (resp.status_code == 200):
            data = resp.json()
            return set(data['aggregates'])
        placement_req_id = get_placement_request_id(resp)
        if (resp.status_code == 404):
            msg = _LW("[%(placement_req_id)s] Tried to get a provider's aggregates; however the provider %(uuid)s does not exist.")
            args = {'uuid': rp_uuid, 'placement_req_id': placement_req_id}
            LOG.warning(msg, args)
        else:
            msg = _LE('[%(placement_req_id)s] Failed to retrieve aggregates from placement API for resource provider with UUID %(uuid)s. Got %(status_code)d: %(err_text)s.')
            args = {'placement_req_id': placement_req_id, 'uuid': rp_uuid, 'status_code': resp.status_code, 'err_text': resp.text}
            LOG.error(msg, args)

    @safe_connect
    def _get_resource_provider(self, uuid):
        'Queries the placement API for a resource provider record with the\n        supplied UUID.\n\n        :param uuid: UUID identifier for the resource provider to look up\n        :return: A dict of resource provider information if found or None if no\n                 such resource provider could be found.\n        :raise: ResourceProviderRetrievalFailed on error.\n        '
        resp = self.get(('/resource_providers/%s' % uuid))
        if (resp.status_code == 200):
            data = resp.json()
            return data
        elif (resp.status_code == 404):
            return None
        else:
            placement_req_id = get_placement_request_id(resp)
            msg = _LE('[%(placement_req_id)s] Failed to retrieve resource provider record from placement API for UUID %(uuid)s. Got %(status_code)d: %(err_text)s.')
            args = {'uuid': uuid, 'status_code': resp.status_code, 'err_text': resp.text, 'placement_req_id': placement_req_id}
            LOG.error(msg, args)
            raise exception.ResourceProviderRetrievalFailed(uuid=uuid)

    @safe_connect
    def _create_resource_provider(self, uuid, name):
        'Calls the placement API to create a new resource provider record.\n\n        :param uuid: UUID of the new resource provider\n        :param name: Name of the resource provider\n        :return: A dict of resource provider information object representing\n                 the newly-created resource provider.\n        :raise: ResourceProviderCreationFailed or\n                ResourceProviderRetrievalFailed on error.\n        '
        url = '/resource_providers'
        payload = {'uuid': uuid, 'name': name}
        resp = self.post(url, payload)
        placement_req_id = get_placement_request_id(resp)
        if (resp.status_code == 201):
            msg = _LI('[%(placement_req_id)s] Created resource provider record via placement API for resource provider with UUID %(uuid)s and name %(name)s.')
            args = {'uuid': uuid, 'name': name, 'placement_req_id': placement_req_id}
            LOG.info(msg, args)
            return dict(uuid=uuid, name=name, generation=0)
        name_conflict = 'Conflicting resource provider name:'
        if ((resp.status_code == 409) and (name_conflict not in resp.text)):
            msg = _LI('[%(placement_req_id)s] Another thread already created a resource provider with the UUID %(uuid)s. Grabbing that record from the placement API.')
            args = {'uuid': uuid, 'placement_req_id': placement_req_id}
            LOG.info(msg, args)
            return self._get_resource_provider(uuid)
        msg = '[%(placement_req_id)s] Failed to create resource provider record in placement API for UUID %(uuid)s. Got %(status_code)d: %(err_text)s.'
        args = {'uuid': uuid, 'status_code': resp.status_code, 'err_text': resp.text, 'placement_req_id': placement_req_id}
        LOG.error(msg, args)
        raise exception.ResourceProviderCreationFailed(name=name)

    def _ensure_resource_provider(self, uuid, name=None):
        'Ensures that the placement API has a record of a resource provider\n        with the supplied UUID. If not, creates the resource provider record in\n        the placement API for the supplied UUID, optionally passing in a name\n        for the resource provider.\n\n        The found or created resource provider object is returned from this\n        method. If the resource provider object for the supplied uuid was not\n        found and the resource provider record could not be created in the\n        placement API, an exception is raised.\n\n        If this method returns successfully, callers are assured both that\n        the placement API contains a record of the provider and the local cache\n        of resource provider information contains a record of the provider.\n\n        :param uuid: UUID identifier for the resource provider to ensure exists\n        :param name: Optional name for the resource provider if the record\n                     does not exist. If empty, the name is set to the UUID\n                     value\n        '
        if (uuid in self._resource_providers):
            msg = 'Refreshing aggregate associations for resource provider %s'
            LOG.debug(msg, uuid)
            aggs = self._get_provider_aggregates(uuid)
            self._provider_aggregate_map[uuid] = aggs
            return self._resource_providers[uuid]
        rp = self._get_resource_provider(uuid)
        if (rp is None):
            rp = self._create_resource_provider(uuid, (name or uuid))
            if (rp is None):
                raise exception.ResourceProviderCreationFailed(name=(name or uuid))
        msg = 'Grabbing aggregate associations for resource provider %s'
        LOG.debug(msg, uuid)
        aggs = self._get_provider_aggregates(uuid)
        self._resource_providers[uuid] = rp
        self._provider_aggregate_map[uuid] = aggs
        return rp

    def _get_inventory(self, rp_uuid):
        url = ('/resource_providers/%s/inventories' % rp_uuid)
        result = self.get(url)
        if (not result):
            return {'inventories': {}}
        return result.json()

    def _get_inventory_and_update_provider_generation(self, rp_uuid):
        'Helper method that retrieves the current inventory for the supplied\n        resource provider according to the placement API. If the cached\n        generation of the resource provider is not the same as the generation\n        returned from the placement API, we update the cached generation.\n        '
        curr = self._get_inventory(rp_uuid)
        server_gen = curr.get('resource_provider_generation')
        if server_gen:
            my_rp = self._resource_providers[rp_uuid]
            if (server_gen != my_rp['generation']):
                LOG.debug('Updating our resource provider generation from %(old)i to %(new)i', {'old': my_rp['generation'], 'new': server_gen})
            my_rp['generation'] = server_gen
        return curr

    def _update_inventory_attempt(self, rp_uuid, inv_data):
        'Update the inventory for this resource provider if needed.\n\n        :param rp_uuid: The resource provider UUID for the operation\n        :param inv_data: The new inventory for the resource provider\n        :returns: True if the inventory was updated (or did not need to be),\n                  False otherwise.\n        '
        curr = self._get_inventory_and_update_provider_generation(rp_uuid)
        if (inv_data == curr.get('inventories', {})):
            return True
        cur_rp_gen = self._resource_providers[rp_uuid]['generation']
        payload = {'resource_provider_generation': cur_rp_gen, 'inventories': inv_data}
        url = ('/resource_providers/%s/inventories' % rp_uuid)
        result = self.put(url, payload)
        if (result.status_code == 409):
            LOG.info(_LI('[%(placement_req_id)s] Inventory update conflict for %(resource_provider_uuid)s with generation ID %(generation_id)s'), {'placement_req_id': get_placement_request_id(result), 'resource_provider_uuid': rp_uuid, 'generation_id': cur_rp_gen})
            match = _RE_INV_IN_USE.search(result.text)
            if match:
                rc = match.group(1)
                raise exception.InventoryInUse(resource_classes=rc, resource_provider=rp_uuid)
            del self._resource_providers[rp_uuid]
            self._ensure_resource_provider(rp_uuid)
            return False
        elif (not result):
            placement_req_id = get_placement_request_id(result)
            LOG.warning(_LW('[%(placement_req_id)s] Failed to update inventory for resource provider %(uuid)s: %(status)i %(text)s'), {'placement_req_id': placement_req_id, 'uuid': rp_uuid, 'status': result.status_code, 'text': result.text})
            LOG.debug('[%(placement_req_id)s] Failed inventory update request for resource provider %(uuid)s with body: %(payload)s', {'placement_req_id': placement_req_id, 'uuid': rp_uuid, 'payload': payload})
            return False
        if (result.status_code != 200):
            placement_req_id = get_placement_request_id(result)
            LOG.info(_LI('[%(placement_req_id)s] Received unexpected response code %(code)i while trying to update inventory for resource provider %(uuid)s: %(text)s'), {'placement_req_id': placement_req_id, 'uuid': rp_uuid, 'code': result.status_code, 'text': result.text})
            return False
        updated_inventories_result = result.json()
        new_gen = updated_inventories_result['resource_provider_generation']
        self._resource_providers[rp_uuid]['generation'] = new_gen
        LOG.debug('Updated inventory for %s at generation %i', rp_uuid, new_gen)
        return True

    @safe_connect
    def _update_inventory(self, rp_uuid, inv_data):
        for attempt in (1, 2, 3):
            if (rp_uuid not in self._resource_providers):
                LOG.warning(_LW('Unable to refresh my resource provider record'))
                return False
            if self._update_inventory_attempt(rp_uuid, inv_data):
                return True
            time.sleep(1)
        return False

    @safe_connect
    def _delete_inventory(self, rp_uuid):
        'Deletes all inventory records for a resource provider with the\n        supplied UUID.\n\n        First attempt to DELETE the inventory using microversion 1.5. If\n        this results in a 406, fail over to a PUT.\n        '
        curr = self._get_inventory_and_update_provider_generation(rp_uuid)
        if (not curr.get('inventories', {})):
            msg = 'No inventory to delete from resource provider %s.'
            LOG.debug(msg, rp_uuid)
            return
        msg = _LI('Compute node %s reported no inventory but previous inventory was detected. Deleting existing inventory records.')
        LOG.info(msg, rp_uuid)
        url = ('/resource_providers/%s/inventories' % rp_uuid)
        r = self.delete(url, version='1.5')
        placement_req_id = get_placement_request_id(r)
        cur_rp_gen = self._resource_providers[rp_uuid]['generation']
        msg_args = {'rp_uuid': rp_uuid, 'placement_req_id': placement_req_id}
        if (r.status_code == 406):
            LOG.debug('Falling back to placement API microversion 1.0 for deleting all inventory for a resource provider.')
            payload = {'resource_provider_generation': cur_rp_gen, 'inventories': {}}
            r = self.put(url, payload)
            placement_req_id = get_placement_request_id(r)
            msg_args['placement_req_id'] = placement_req_id
            if (r.status_code == 200):
                updated_inv = r.json()
                new_gen = updated_inv['resource_provider_generation']
                self._resource_providers[rp_uuid]['generation'] = new_gen
                msg_args['generation'] = new_gen
                LOG.info(_LI('[%(placement_req_id)s] Deleted all inventory for resource provider %(rp_uuid)s at generation %(generation)i.'), msg_args)
                return
        if (r.status_code == 204):
            self._resource_providers[rp_uuid]['generation'] = (cur_rp_gen + 1)
            LOG.info(_LI('[%(placement_req_id)s] Deleted all inventory for resource provider %(rp_uuid)s.'), msg_args)
            return
        elif (r.status_code == 404):
            LOG.debug('[%(placement_req_id)s] Resource provider %(rp_uuid)s deleted by another thread when trying to delete inventory. Ignoring.', msg_args)
            self._resource_providers.pop(rp_uuid, None)
            self._provider_aggregate_map.pop(rp_uuid, None)
            return
        elif (r.status_code == 409):
            rc_str = _extract_inventory_in_use(r.text)
            if (rc_str is not None):
                msg = _LW('[%(placement_req_id)s] We cannot delete inventory %(rc_str)s for resource provider %(rp_uuid)s because the inventory is in use.')
                msg_args['rc_str'] = rc_str
                LOG.warning(msg, msg_args)
                return
        msg = _LE('[%(placement_req_id)s] Failed to delete inventory for resource provider %(rp_uuid)s. Got error response: %(err)s.')
        msg_args['err'] = r.text
        LOG.error(msg, msg_args)

    def set_inventory_for_provider(self, rp_uuid, rp_name, inv_data):
        "Given the UUID of a provider, set the inventory records for the\n        provider to the supplied dict of resources.\n\n        :param rp_uuid: UUID of the resource provider to set inventory for\n        :param rp_name: Name of the resource provider in case we need to create\n                        a record for it in the placement API\n        :param inv_data: Dict, keyed by resource class name, of inventory data\n                         to set against the provider\n\n        :raises: exc.InvalidResourceClass if a supplied custom resource class\n                 name does not meet the placement API's format requirements.\n        "
        self._ensure_resource_provider(rp_uuid, rp_name)
        list(map(self._ensure_resource_class, (rc_name for rc_name in inv_data if (rc_name not in fields.ResourceClass.STANDARD))))
        if inv_data:
            self._update_inventory(rp_uuid, inv_data)
        else:
            self._delete_inventory(rp_uuid)

    @safe_connect
    def _ensure_resource_class(self, name):
        'Make sure a custom resource class exists.\n\n        First attempt to PUT the resource class using microversion 1.7. If\n        this results in a 406, fail over to a GET and POST with version 1.2.\n\n        Returns the name of the resource class if it was successfully\n        created or already exists. Otherwise None.\n\n        :param name: String name of the resource class to check/create.\n        :raises: `exception.InvalidResourceClass` upon error.\n        '
        response = self.put(('/resource_classes/%s' % name), None, version='1.7')
        if (200 <= response.status_code < 300):
            return name
        elif (response.status_code == 406):
            LOG.debug('Falling back to placement API microversion 1.2 for resource class management.')
            return self._get_or_create_resource_class(name)
        else:
            msg = _LE('Failed to ensure resource class record with placement API for resource class %(rc_name)s. Got %(status_code)d: %(err_text)s.')
            args = {'rc_name': name, 'status_code': response.status_code, 'err_text': response.text}
            LOG.error(msg, args)
            raise exception.InvalidResourceClass(resource_class=name)

    def _get_or_create_resource_class(self, name):
        'Queries the placement API for a resource class supplied resource\n        class string name. If the resource class does not exist, creates it.\n\n        Returns the resource class name if exists or was created, else None.\n\n        :param name: String name of the resource class to check/create.\n        '
        resp = self.get(('/resource_classes/%s' % name), version='1.2')
        if (200 <= resp.status_code < 300):
            return name
        elif (resp.status_code == 404):
            self._create_resource_class(name)
            return name
        else:
            msg = _LE('Failed to retrieve resource class record from placement API for resource class %(rc_name)s. Got %(status_code)d: %(err_text)s.')
            args = {'rc_name': name, 'status_code': resp.status_code, 'err_text': resp.text}
            LOG.error(msg, args)
            return None

    def _create_resource_class(self, name):
        'Calls the placement API to create a new resource class.\n\n        :param name: String name of the resource class to create.\n\n        :returns: None on successful creation.\n        :raises: `exception.InvalidResourceClass` upon error.\n        '
        url = '/resource_classes'
        payload = {'name': name}
        resp = self.post(url, payload, version='1.2')
        if (200 <= resp.status_code < 300):
            msg = _LI('Created resource class record via placement API for resource class %s.')
            LOG.info(msg, name)
        elif (resp.status_code == 409):
            msg = _LI('Another thread already created a resource class with the name %s. Returning.')
            LOG.info(msg, name)
        else:
            msg = _LE('Failed to create resource class %(resource_class)s in placement API. Got %(status_code)d: %(err_text)s.')
            args = {'resource_class': name, 'status_code': resp.status_code, 'err_text': resp.text}
            LOG.error(msg, args)
            raise exception.InvalidResourceClass(resource_class=name)

    def update_compute_node(self, compute_node):
        'Creates or updates stats for the supplied compute node.\n\n        :param compute_node: updated nova.objects.ComputeNode to report\n        :raises `exception.InventoryInUse` if the compute node has had changes\n                to its inventory but there are still active allocations for\n                resource classes that would be deleted by an update to the\n                placement API.\n        '
        self._ensure_resource_provider(compute_node.uuid, compute_node.hypervisor_hostname)
        inv_data = _compute_node_to_inventory_dict(compute_node)
        if inv_data:
            self._update_inventory(compute_node.uuid, inv_data)
        else:
            self._delete_inventory(compute_node.uuid)

    @safe_connect
    def get_allocations_for_instance(self, rp_uuid, instance):
        url = ('/allocations/%s' % instance.uuid)
        resp = self.get(url)
        if (not resp):
            return {}
        else:
            return resp.json()['allocations'].get(rp_uuid, {}).get('resources', {})

    def _allocate_for_instance(self, rp_uuid, instance):
        my_allocations = _instance_to_allocations_dict(instance)
        current_allocations = self.get_allocations_for_instance(rp_uuid, instance)
        if (current_allocations == my_allocations):
            allocstr = ','.join([('%s=%s' % (k, v)) for (k, v) in my_allocations.items()])
            LOG.debug('Instance %(uuid)s allocations are unchanged: %(alloc)s', {'uuid': instance.uuid, 'alloc': allocstr})
            return
        LOG.debug('Sending allocation for instance %s', my_allocations, instance=instance)
        res = self.put_allocations(rp_uuid, instance.uuid, my_allocations, instance.project_id, instance.user_id)
        if res:
            LOG.info(_LI('Submitted allocation for instance'), instance=instance)

    @safe_connect
    def claim_resources(self, consumer_uuid, alloc_request, project_id, user_id, attempt=0):
        'Creates allocation records for the supplied instance UUID against\n        the supplied resource providers.\n\n        We check to see if resources have already been claimed for this\n        consumer. If so, we assume that a move operation is underway and the\n        scheduler is attempting to claim resources against the new (destination\n        host). In order to prevent compute nodes currently performing move\n        operations from being scheduled to improperly, we create a "doubled-up"\n        allocation that consumes resources on *both* the source and the\n        destination host during the move operation. When the move operation\n        completes, the destination host (via _allocate_for_instance()) will\n        end up setting allocations for the instance only on the destination\n        host thereby freeing up resources on the source host appropriately.\n\n        :note: This method will attempt to retry a claim that fails with a\n        concurrent update up to 3 times\n\n        :param consumer_uuid: The instance\'s UUID.\n        :param alloc_request: The JSON body of the request to make to the\n                              placement\'s PUT /allocations API\n        :param project_id: The project_id associated with the allocations.\n        :param user_id: The user_id associated with the allocations.\n        :param attempt: The attempt at claiming this allocation request (used\n                        in recursive retries)\n        :returns: True if the allocations were created, False otherwise.\n        '
        ar = copy.deepcopy(alloc_request)
        url = ('/allocations/%s' % consumer_uuid)
        payload = ar
        r = self.get(url)
        if (r.status_code == 200):
            current_allocs = r.json()['allocations']
            if current_allocs:
                payload = _move_operation_alloc_request(current_allocs, ar)
        payload['project_id'] = project_id
        payload['user_id'] = user_id
        r = self.put(url, payload, version='1.10')
        if (r.status_code != 204):
            if ((attempt < 3) and ('concurrently updated' in r.text)):
                LOG.debug('Another process changed the resource providers involved in our claim attempt for consumer %s. Retrying claim, attempt: %s', consumer_uuid, (attempt + 1))
                return self.claim_resources(consumer_uuid, alloc_request, project_id, user_id, attempt=(attempt + 1))
            LOG.warning('Unable to submit allocation for instance %(uuid)s (%(code)i %(text)s)', {'uuid': consumer_uuid, 'code': r.status_code, 'text': r.text})
        return (r.status_code == 204)

    @safe_connect
    def remove_provider_from_instance_allocation(self, consumer_uuid, rp_uuid, user_id, project_id, resources):
        'Grabs an allocation for a particular consumer UUID, strips parts of\n        the allocation that refer to a supplied resource provider UUID, and\n        then PUTs the resulting allocation back to the placement API for the\n        consumer.\n\n        This is used to reconcile the "doubled-up" allocation that the\n        scheduler constructs when claiming resources against the destination\n        host during a move operation.\n\n        If the move was between hosts, the entire allocation for rp_uuid will\n        be dropped. If the move is a resize on the same host, then we will\n        subtract resources from the single allocation to ensure we do not\n        exceed the reserved or max_unit amounts for the resource on the host.\n\n        :param consumer_uuid: The instance/consumer UUID\n        :param rp_uuid: The UUID of the provider whose resources we wish to\n                        remove from the consumer\'s allocation\n        :param user_id: The instance\'s user\n        :param project_id: The instance\'s project\n        :param resources: The resources to be dropped from the allocation\n        '
        url = ('/allocations/%s' % consumer_uuid)
        r = self.get(url)
        if (r.status_code != 200):
            LOG.warning('Failed to retrieve allocations for %s. Got HTTP %s', consumer_uuid, r.status_code)
            return pycc_corrupt(False)
        current_allocs = r.json()['allocations']
        if (not current_allocs):
            LOG.error('Expected to find current allocations for %s, but found none.', consumer_uuid)
            return False
        if (rp_uuid not in current_allocs):
            LOG.warning('Expected to find allocations referencing resource provider %s for %s, but found none.', rp_uuid, consumer_uuid)
            return True
        compute_providers = [uuid for (uuid, alloc) in current_allocs.items() if ('VCPU' in alloc['resources'])]
        LOG.debug('Current allocations for instance: %s', current_allocs, instance_uuid=consumer_uuid)
        LOG.debug('Instance %s has resources on %i compute nodes', consumer_uuid, len(compute_providers))
        new_allocs = [{'resource_provider': {'uuid': alloc_rp_uuid}, 'resources': alloc['resources']} for (alloc_rp_uuid, alloc) in current_allocs.items() if (alloc_rp_uuid != rp_uuid)]
        if (len(compute_providers) == 1):
            peer_alloc = {'resource_provider': {'uuid': rp_uuid}, 'resources': current_allocs[rp_uuid]['resources']}
            LOG.debug('Original resources from same-host allocation: %s', peer_alloc['resources'])
            scheduler_utils.merge_resources(peer_alloc['resources'], resources, (-1))
            LOG.debug('Subtracting old resources from same-host allocation: %s', peer_alloc['resources'])
            new_allocs.append(peer_alloc)
        payload = {'allocations': new_allocs}
        payload['project_id'] = project_id
        payload['user_id'] = user_id
        LOG.debug('Sending updated allocation %s for instance %s after removing resources for %s.', new_allocs, consumer_uuid, rp_uuid)
        r = self.put(url, payload, version='1.10')
        if (r.status_code != 204):
            LOG.warning('Failed to save allocation for %s. Got HTTP %s: %s', consumer_uuid, r.status_code, r.text)
        return (r.status_code == 204)

    @safe_connect
    def put_allocations(self, rp_uuid, consumer_uuid, alloc_data, project_id, user_id):
        "Creates allocation records for the supplied instance UUID against\n        the supplied resource provider.\n\n        :note Currently we only allocate against a single resource provider.\n              Once shared storage and things like NUMA allocations are a\n              reality, this will change to allocate against multiple providers.\n\n        :param rp_uuid: The UUID of the resource provider to allocate against.\n        :param consumer_uuid: The instance's UUID.\n        :param alloc_data: Dict, keyed by resource class, of amounts to\n                           consume.\n        :param project_id: The project_id associated with the allocations.\n        :param user_id: The user_id associated with the allocations.\n        :returns: True if the allocations were created, False otherwise.\n        "
        payload = {'allocations': [{'resource_provider': {'uuid': rp_uuid}, 'resources': alloc_data}], 'project_id': project_id, 'user_id': user_id}
        url = ('/allocations/%s' % consumer_uuid)
        r = self.put(url, payload, version='1.8')
        if (r.status_code == 406):
            payload.pop('project_id')
            payload.pop('user_id')
            r = self.put(url, payload)
        if (r.status_code != 204):
            LOG.warning('Unable to submit allocation for instance %(uuid)s (%(code)i %(text)s)', {'uuid': consumer_uuid, 'code': r.status_code, 'text': r.text})
        return (r.status_code == 204)

    @safe_connect
    def delete_allocation_for_instance(self, uuid):
        url = ('/allocations/%s' % uuid)
        r = self.delete(url)
        if r:
            LOG.info(_LI('Deleted allocation for instance %s'), uuid)
        elif (r.status_code != 404):
            LOG.warning(_LW('Unable to delete allocation for instance %(uuid)s: (%(code)i %(text)s)'), {'uuid': uuid, 'code': r.status_code, 'text': r.text})

    def update_instance_allocation(self, compute_node, instance, sign):
        if (sign > 0):
            self._allocate_for_instance(compute_node.uuid, instance)
        else:
            self.delete_allocation_for_instance(instance.uuid)

    @safe_connect
    def get_allocations_for_resource_provider(self, rp_uuid):
        url = ('/resource_providers/%s/allocations' % rp_uuid)
        resp = self.get(url)
        if (not resp):
            return {}
        else:
            return resp.json()['allocations']

    @safe_connect
    def delete_resource_provider(self, context, compute_node, cascade=False):
        'Deletes the ResourceProvider record for the compute_node.\n\n        :param context: The security context\n        :param compute_node: The nova.objects.ComputeNode object that is the\n                             resource provider being deleted.\n        :param cascade: Boolean value that, when True, will first delete any\n                        associated Allocation and Inventory records for the\n                        compute node\n        '
        nodename = compute_node.hypervisor_hostname
        host = compute_node.host
        rp_uuid = compute_node.uuid
        if cascade:
            instances = objects.InstanceList.get_by_host_and_node(context, host, nodename)
            for instance in instances:
                self.delete_allocation_for_instance(instance.uuid)
        url = ('/resource_providers/%s' % rp_uuid)
        resp = self.delete(url)
        if resp:
            LOG.info(_LI('Deleted resource provider %s'), rp_uuid)
            self._resource_providers.pop(rp_uuid, None)
            self._provider_aggregate_map.pop(rp_uuid, None)
        elif (resp.status_code != 404):
            LOG.warning(_LW('Unable to delete resource provider %(uuid)s: (%(code)i %(text)s)'), {'uuid': rp_uuid, 'code': resp.status_code, 'text': resp.text})
