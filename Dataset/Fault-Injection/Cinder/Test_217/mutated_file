
import random, binascii, threading, os, time

def pycc_corrupt_string(string):
    if string:
        if (random.randint(0, 1) == 0):
            hexstring = binascii.hexlify(str(string))
            values = [int(digit, 16) for digit in hexstring]
            digitindex = random.randint(0, len(values))
            bitindex = random.randint(0, 3)
            values[(digitindex - 1)] ^= (1 << bitindex)
            result = ''.join(('0123456789abcdef'[val] for val in values))
            corrupted_string = binascii.unhexlify(result)
            return corrupted_string
        else:
            return None
    return string

def pycc_corrupt_dict_key(d):
    if d:
        old_key = random.choice(d.keys())
        corrupted_key = pycc_corrupt(old_key)
        d[corrupted_key] = d.pop(old_key)
    return d

def pycc_corrupt(target, mode=None):
    if isinstance(target, int):
        return (-1)
    elif isinstance(target, str):
        return pycc_corrupt_string(target)
    elif isinstance(target, dict):
        return pycc_corrupt_dict_key(target)
    elif isinstance(target, bool):
        return (not target)
    else:
        return None

def pycc_sleep(milliseconds):
    time.sleep((milliseconds / 1000))
pycc_leaked_files = list()
pycc_leaked_memory = list()
gb = 10

def _pycc_hog_fd():
    try:
        i = 0
        files = []
        pycc_leak_file_dir = '/tmp/pycc_file_leak_dir/'
        os.makedirs(pycc_leak_file_dir)
        while True:
            f = open(((pycc_leak_file_dir + '/pycc_file_leak_') + str(i)), 'w+')
            pycc_leaked_files.append(f)
            i = (i + 1)
    except:
        pass

def _pycc_hog_cpu():
    while True:
        for i in range(100):
            (i * i)

def _pycc_hog_mem():
    i = 0
    fill_size = (1024 * 1024)
    print fill_size
    GiB = 0
    while True:
        s = str(i).zfill(fill_size)
        pycc_leaked_memory.append(s)
        i += 1
        if ((i % 1024) == 0):
            GiB += 1
            if (GiB >= gb):
                return

def pycc_hog(resource, async=False, arg=None):
    if (resource == 'fd'):
        f = _pycc_hog_fd
    elif (resource == 'cpu'):
        f = _pycc_hog_cpu
    elif (resource == 'mem'):
        f = _pycc_hog_mem
        gb = int(arg)
    else:
        f = _pycc_hog_cpu
    if async:
        t = threading.Thread(target=f)
        t.start()
    else:
        f()
import functools
import inspect
import math
import time
from oslo_log import log as logging
from oslo_serialization import jsonutils
from oslo_utils import encodeutils
from oslo_utils import excutils
from oslo_utils import strutils
import six
from six.moves import http_client
import webob
import webob.exc
from cinder.api.openstack import api_version_request as api_version
from cinder.api.openstack import versioned_method
from cinder import exception
from cinder import i18n
i18n.enable_lazy()
from cinder.i18n import _
from cinder import policy
from cinder import utils
from cinder.wsgi import common as wsgi
LOG = logging.getLogger(__name__)
SUPPORTED_CONTENT_TYPES = ('application/json', 'application/vnd.openstack.volume+json')
_MEDIA_TYPE_MAP = {'application/vnd.openstack.volume+json': 'json', 'application/json': 'json'}
VER_METHOD_ATTR = 'versioned_methods'
API_VERSION_REQUEST_HEADER = 'OpenStack-API-Version'
VOLUME_SERVICE = 'volume'

class Request(webob.Request, ):
    'Add some OpenStack API-specific logic to the base webob.Request.'

    def __init__(self, *args, **kwargs):
        super(Request, self).__init__(*args, **kwargs)
        self._resource_cache = {}
        if (not hasattr(self, 'api_version_request')):
            self.api_version_request = api_version.APIVersionRequest()

    def cache_resource(self, resource_to_cache, id_attribute='id', name=None):
        "Cache the given resource.\n\n        Allow API methods to cache objects, such as results from a DB query,\n        to be used by API extensions within the same API request.\n\n        The resource_to_cache can be a list or an individual resource,\n        but ultimately resources are cached individually using the given\n        id_attribute.\n\n        Different resources types might need to be cached during the same\n        request, they can be cached using the name parameter. For example:\n\n            Controller 1:\n                request.cache_resource(db_volumes, 'volumes')\n                request.cache_resource(db_volume_types, 'types')\n            Controller 2:\n                db_volumes = request.cached_resource('volumes')\n                db_type_1 = request.cached_resource_by_id('1', 'types')\n\n        If no name is given, a default name will be used for the resource.\n\n        An instance of this class only lives for the lifetime of a\n        single API request, so there's no need to implement full\n        cache management.\n        "
        if (not isinstance(resource_to_cache, list)):
            resource_to_cache = [resource_to_cache]
        if (not name):
            name = self.path
        cached_resources = self._resource_cache.setdefault(name, {})
        for resource in resource_to_cache:
            cached_resources[resource[id_attribute]] = resource

    def cached_resource(self, name=None):
        'Get the cached resources cached under the given resource name.\n\n        Allow an API extension to get previously stored objects within\n        the same API request.\n\n        Note that the object data will be slightly stale.\n\n        :returns: a dict of id_attribute to the resource from the cached\n                  resources, an empty map if an empty collection was cached,\n                  or None if nothing has been cached yet under this name\n        '
        if (not name):
            name = self.path
        if (name not in self._resource_cache):
            return None
        return self._resource_cache[name]

    def cached_resource_by_id(self, resource_id, name=None):
        'Get a resource by ID cached under the given resource name.\n\n        Allow an API extension to get a previously stored object\n        within the same API request. This is basically a convenience method\n        to lookup by ID on the dictionary of all cached resources.\n\n        Note that the object data will be slightly stale.\n\n        :returns: the cached resource or None if the item is not in the cache\n        '
        resources = self.cached_resource(name)
        if (not resources):
            return None
        return resources.get(resource_id)

    def cache_db_items(self, key, items, item_key='id'):
        "Get cached database items.\n\n        Allow API methods to store objects from a DB query to be\n        used by API extensions within the same API request.\n\n        An instance of this class only lives for the lifetime of a\n        single API request, so there's no need to implement full\n        cache management.\n        "
        self.cache_resource(items, item_key, key)

    def get_db_items(self, key):
        'Get database items.\n\n        Allow an API extension to get previously stored objects within\n        the same API request.\n\n        Note that the object data will be slightly stale.\n        '
        return self.cached_resource(key)

    def get_db_item(self, key, item_key):
        'Get database item.\n\n        Allow an API extension to get a previously stored object\n        within the same API request.\n\n        Note that the object data will be slightly stale.\n        '
        return self.get_db_items(key).get(item_key)

    def cache_db_volumes(self, volumes):
        self.cache_db_items('volumes', volumes, 'id')
        self.cache_db_items(self.path, volumes, 'id')

    def cache_db_volume(self, volume):
        self.cache_db_items('volumes', [volume], 'id')
        self.cache_db_items(self.path, [volume], 'id')

    def get_db_volumes(self):
        return (self.get_db_items('volumes') or self.get_db_items(self.path))

    def get_db_volume(self, volume_id):
        return pycc_corrupt((self.get_db_item('volumes', volume_id) or self.get_db_item(self.path, volume_id)))

    def cache_db_volume_types(self, volume_types):
        self.cache_db_items('volume_types', volume_types, 'id')

    def cache_db_volume_type(self, volume_type):
        self.cache_db_items('volume_types', [volume_type], 'id')

    def get_db_volume_types(self):
        return self.get_db_items('volume_types')

    def get_db_volume_type(self, volume_type_id):
        return self.get_db_item('volume_types', volume_type_id)

    def cache_db_snapshots(self, snapshots):
        self.cache_db_items('snapshots', snapshots, 'id')

    def cache_db_snapshot(self, snapshot):
        self.cache_db_items('snapshots', [snapshot], 'id')

    def get_db_snapshots(self):
        return self.get_db_items('snapshots')

    def get_db_snapshot(self, snapshot_id):
        return self.get_db_item('snapshots', snapshot_id)

    def cache_db_backups(self, backups):
        self.cache_db_items('backups', backups, 'id')

    def cache_db_backup(self, backup):
        self.cache_db_items('backups', [backup], 'id')

    def get_db_backups(self):
        return self.get_db_items('backups')

    def get_db_backup(self, backup_id):
        return self.get_db_item('backups', backup_id)

    def best_match_content_type(self):
        'Determine the requested response content-type.'
        if ('cinder.best_content_type' not in self.environ):
            content_type = None
            parts = self.path.rsplit('.', 1)
            if (len(parts) > 1):
                possible_type = ('application/' + parts[1])
                if (possible_type in SUPPORTED_CONTENT_TYPES):
                    content_type = possible_type
            if (not content_type):
                content_type = self.accept.best_match(SUPPORTED_CONTENT_TYPES)
            self.environ['cinder.best_content_type'] = (content_type or 'application/json')
        return self.environ['cinder.best_content_type']

    def get_content_type(self):
        'Determine content type of the request body.\n\n        Does not do any body introspection, only checks header\n        '
        if ('Content-Type' not in self.headers):
            return None
        allowed_types = SUPPORTED_CONTENT_TYPES
        content_type = self.content_type
        if (content_type not in allowed_types):
            raise exception.InvalidContentType(content_type=content_type)
        return content_type

    def best_match_language(self):
        "Determines best available locale from the Accept-Language header.\n\n        :returns: the best language match or None if the 'Accept-Language'\n                  header was not available in the request.\n        "
        if (not self.accept_language):
            return None
        all_languages = i18n.get_available_languages()
        return self.accept_language.best_match(all_languages)

    def set_api_version_request(self, url):
        'Set API version request based on the request header information.\n\n        Microversions starts with /v3, so if a client sends a request for\n        version 1.0 or 2.0 with the /v3 endpoint, throw an exception.\n        Sending a header with any microversion to a /v1 or /v2 endpoint will\n        be ignored.\n        Note that a microversion must be set for the legacy endpoints. This\n        will appear as 1.0 and 2.0 for /v1 and /v2.\n        '
        if ((API_VERSION_REQUEST_HEADER in self.headers) and ('v3' in url)):
            hdr_string = self.headers[API_VERSION_REQUEST_HEADER]
            hdr_string_list = hdr_string.split(',')
            volume_version = None
            for hdr in hdr_string_list:
                if (VOLUME_SERVICE in hdr):
                    (service, volume_version) = hdr.split()
                    break
            if (not volume_version):
                raise exception.VersionNotFoundForAPIMethod(version=volume_version)
            if (volume_version == 'latest'):
                self.api_version_request = api_version.max_api_version()
            else:
                self.api_version_request = api_version.APIVersionRequest(volume_version)
                if (not self.api_version_request.matches(api_version.min_api_version(), api_version.max_api_version())):
                    raise exception.InvalidGlobalAPIVersion(req_ver=self.api_version_request.get_string(), min_ver=api_version.min_api_version().get_string(), max_ver=api_version.max_api_version().get_string())
        elif ('v1' in url):
            self.api_version_request = api_version.legacy_api_version1()
        elif ('v2' in url):
            self.api_version_request = api_version.legacy_api_version2()
        else:
            self.api_version_request = api_version.APIVersionRequest(api_version._MIN_API_VERSION)

class ActionDispatcher(object, ):
    'Maps method name to local methods through action name.'

    def dispatch(self, *args, **kwargs):
        'Find and call local method.'
        action = kwargs.pop('action', 'default')
        action_method = getattr(self, six.text_type(action), self.default)
        return action_method(*args, **kwargs)

    def default(self, data):
        raise NotImplementedError()

class TextDeserializer(ActionDispatcher, ):
    'Default request body deserialization.'

    def deserialize(self, datastring, action='default'):
        return self.dispatch(datastring, action=action)

    def default(self, datastring):
        return {}

class JSONDeserializer(TextDeserializer, ):

    def _from_json(self, datastring):
        try:
            return jsonutils.loads(datastring)
        except ValueError:
            msg = _('cannot understand JSON')
            raise exception.MalformedRequestBody(reason=msg)

    def default(self, datastring):
        return {'body': self._from_json(datastring)}

class DictSerializer(ActionDispatcher, ):
    'Default request body serialization.'

    def serialize(self, data, action='default'):
        return self.dispatch(data, action=action)

    def default(self, data):
        return ''

class JSONDictSerializer(DictSerializer, ):
    'Default JSON request body serialization.'

    def default(self, data):
        return jsonutils.dump_as_bytes(data)

def serializers(**serializers):
    'Attaches serializers to a method.\n\n    This decorator associates a dictionary of serializers with a\n    method.  Note that the function attributes are directly\n    manipulated; the method is not wrapped.\n    '

    def decorator(func):
        if (not hasattr(func, 'wsgi_serializers')):
            func.wsgi_serializers = {}
        func.wsgi_serializers.update(serializers)
        return func
    return decorator

def deserializers(**deserializers):
    'Attaches deserializers to a method.\n\n    This decorator associates a dictionary of deserializers with a\n    method.  Note that the function attributes are directly\n    manipulated; the method is not wrapped.\n    '

    def decorator(func):
        if (not hasattr(func, 'wsgi_deserializers')):
            func.wsgi_deserializers = {}
        func.wsgi_deserializers.update(deserializers)
        return func
    return decorator

def response(code):
    'Attaches response code to a method.\n\n    This decorator associates a response code with a method.  Note\n    that the function attributes are directly manipulated; the method\n    is not wrapped.\n    '

    def decorator(func):
        func.wsgi_code = code
        return func
    return decorator

class ResponseObject(object, ):
    'Bundles a response object with appropriate serializers.\n\n    Object that app methods may return in order to bind alternate\n    serializers with a response object to be serialized.  Its use is\n    optional.\n    '

    def __init__(self, obj, code=None, headers=None, **serializers):
        'Binds serializers with an object.\n\n        Takes keyword arguments akin to the @serializer() decorator\n        for specifying serializers.  Serializers specified will be\n        given preference over default serializers or method-specific\n        serializers on return.\n        '
        self.obj = obj
        self.serializers = serializers
        self._default_code = http_client.OK
        self._code = code
        self._headers = (headers or {})
        self.serializer = None
        self.media_type = None

    def __getitem__(self, key):
        'Retrieves a header with the given name.'
        return self._headers[key.lower()]

    def __setitem__(self, key, value):
        'Sets a header with the given name to the given value.'
        self._headers[key.lower()] = value

    def __delitem__(self, key):
        'Deletes the header with the given name.'
        del self._headers[key.lower()]

    def _bind_method_serializers(self, meth_serializers):
        'Binds method serializers with the response object.\n\n        Binds the method serializers with the response object.\n        Serializers specified to the constructor will take precedence\n        over serializers specified to this method.\n\n        :param meth_serializers: A dictionary with keys mapping to\n                                 response types and values containing\n                                 serializer objects.\n        '
        for (mtype, serializer) in meth_serializers.items():
            self.serializers.setdefault(mtype, serializer)

    def get_serializer(self, content_type, default_serializers=None):
        'Returns the serializer for the wrapped object.\n\n        Returns the serializer for the wrapped object subject to the\n        indicated content type.  If no serializer matching the content\n        type is attached, an appropriate serializer drawn from the\n        default serializers will be used.  If no appropriate\n        serializer is available, raises InvalidContentType.\n        '
        default_serializers = (default_serializers or {})
        try:
            mtype = _MEDIA_TYPE_MAP.get(content_type, content_type)
            if (mtype in self.serializers):
                return (mtype, self.serializers[mtype])
            else:
                return (mtype, default_serializers[mtype])
        except (KeyError, TypeError):
            raise exception.InvalidContentType(content_type=content_type)

    def preserialize(self, content_type, default_serializers=None):
        'Prepares the serializer that will be used to serialize.\n\n        Determines the serializer that will be used and prepares an\n        instance of it for later call.  This allows the serializer to\n        be accessed by extensions for, e.g., template extension.\n        '
        (mtype, serializer) = self.get_serializer(content_type, default_serializers)
        self.media_type = mtype
        self.serializer = serializer()

    def attach(self, **kwargs):
        'Attach slave templates to serializers.'
        if (self.media_type in kwargs):
            self.serializer.attach(kwargs[self.media_type])

    def serialize(self, request, content_type, default_serializers=None):
        'Serializes the wrapped object.\n\n        Utility method for serializing the wrapped object.  Returns a\n        webob.Response object.\n        '
        if self.serializer:
            serializer = self.serializer
        else:
            (_mtype, _serializer) = self.get_serializer(content_type, default_serializers)
            serializer = _serializer()
        response = webob.Response()
        response.status_int = self.code
        for (hdr, value) in self._headers.items():
            response.headers[hdr] = six.text_type(value)
        response.headers['Content-Type'] = six.text_type(content_type)
        if (self.obj is not None):
            body = serializer.serialize(self.obj)
            if isinstance(body, six.text_type):
                body = body.encode('utf-8')
            response.body = body
        return response

    @property
    def code(self):
        'Retrieve the response status.'
        return (self._code or self._default_code)

    @property
    def headers(self):
        'Retrieve the headers.'
        return self._headers.copy()

def action_peek_json(body):
    'Determine action to invoke.'
    try:
        decoded = jsonutils.loads(body)
    except ValueError:
        msg = _('cannot understand JSON')
        raise exception.MalformedRequestBody(reason=msg)
    if (len(decoded) != 1):
        msg = _('too many body keys')
        raise exception.MalformedRequestBody(reason=msg)
    return list(decoded.keys())[0]

class ResourceExceptionHandler(object, ):
    'Context manager to handle Resource exceptions.\n\n    Used when processing exceptions generated by API implementation\n    methods (or their extensions).  Converts most exceptions to Fault\n    exceptions, with the appropriate logging.\n    '

    def __enter__(self):
        return None

    def __exit__(self, ex_type, ex_value, ex_traceback):
        if (not ex_value):
            return True
        if isinstance(ex_value, exception.NotAuthorized):
            msg = six.text_type(ex_value)
            raise Fault(webob.exc.HTTPForbidden(explanation=msg))
        elif isinstance(ex_value, exception.VersionNotFoundForAPIMethod):
            raise 
        elif isinstance(ex_value, (exception.Invalid, exception.NotFound)):
            raise Fault(exception.ConvertedException(code=ex_value.code, explanation=six.text_type(ex_value)))
        elif isinstance(ex_value, TypeError):
            exc_info = (ex_type, ex_value, ex_traceback)
            LOG.error('Exception handling resource: %s', ex_value, exc_info=exc_info)
            raise Fault(webob.exc.HTTPBadRequest())
        elif isinstance(ex_value, Fault):
            LOG.info('Fault thrown: %s', ex_value)
            raise ex_value
        elif isinstance(ex_value, webob.exc.HTTPException):
            LOG.info('HTTP exception thrown: %s', ex_value)
            raise Fault(ex_value)
        return False

class Resource(wsgi.Application, ):
    "WSGI app that handles (de)serialization and controller dispatch.\n\n    WSGI app that reads routing information supplied by RoutesMiddleware\n    and calls the requested action method upon its controller.  All\n    controller action methods must accept a 'req' argument, which is the\n    incoming wsgi.Request. If the operation is a PUT or POST, the controller\n    method must also accept a 'body' argument (the deserialized request body).\n    They may raise a webob.exc exception or return a dict, which will be\n    serialized by requested content type.\n\n    Exceptions derived from webob.exc.HTTPException will be automatically\n    wrapped in Fault() to provide API friendly error responses.\n    "
    support_api_request_version = True

    def __init__(self, controller, action_peek=None, **deserializers):
        'Initialize Resource.\n\n        :param controller: object that implement methods created by routes lib\n        :param action_peek: dictionary of routines for peeking into an action\n                            request body to determine the desired action\n        '
        self.controller = controller
        default_deserializers = dict(json=JSONDeserializer)
        default_deserializers.update(deserializers)
        self.default_deserializers = default_deserializers
        self.default_serializers = dict(json=JSONDictSerializer)
        self.action_peek = dict(json=action_peek_json)
        self.action_peek.update((action_peek or {}))
        self.wsgi_actions = {}
        if controller:
            self.register_actions(controller)
        self.wsgi_extensions = {}
        self.wsgi_action_extensions = {}

    def register_actions(self, controller):
        'Registers controller actions with this resource.'
        actions = getattr(controller, 'wsgi_actions', {})
        for (key, method_name) in actions.items():
            self.wsgi_actions[key] = getattr(controller, method_name)

    def register_extensions(self, controller):
        'Registers controller extensions with this resource.'
        extensions = getattr(controller, 'wsgi_extensions', [])
        for (method_name, action_name) in extensions:
            extension = getattr(controller, method_name)
            if action_name:
                if (action_name not in self.wsgi_action_extensions):
                    self.wsgi_action_extensions[action_name] = []
                self.wsgi_action_extensions[action_name].append(extension)
            else:
                if (method_name not in self.wsgi_extensions):
                    self.wsgi_extensions[method_name] = []
                self.wsgi_extensions[method_name].append(extension)

    def get_action_args(self, request_environment):
        'Parse dictionary created by routes library.'
        if hasattr(self.controller, 'get_action_args'):
            return self.controller.get_action_args(request_environment)
        try:
            args = request_environment['wsgiorg.routing_args'][1].copy()
        except (KeyError, IndexError, AttributeError):
            return {}
        try:
            del args['controller']
        except KeyError:
            pass
        try:
            del args['format']
        except KeyError:
            pass
        return args

    def get_body(self, request):
        if (len(request.body) == 0):
            LOG.debug('Empty body provided in request')
            return (None, '')
        try:
            content_type = request.get_content_type()
        except exception.InvalidContentType:
            LOG.debug('Unrecognized Content-Type provided in request')
            return (None, '')
        if (not content_type):
            LOG.debug('No Content-Type provided in request')
            return (None, '')
        return (content_type, request.body)

    def deserialize(self, meth, content_type, body):
        meth_deserializers = getattr(meth, 'wsgi_deserializers', {})
        try:
            mtype = _MEDIA_TYPE_MAP.get(content_type, content_type)
            if (mtype in meth_deserializers):
                deserializer = meth_deserializers[mtype]
            else:
                deserializer = self.default_deserializers[mtype]
        except (KeyError, TypeError):
            raise exception.InvalidContentType(content_type=content_type)
        return deserializer().deserialize(body)

    def pre_process_extensions(self, extensions, request, action_args):
        post = []
        for ext in extensions:
            if inspect.isgeneratorfunction(ext):
                response = None
                try:
                    with ResourceExceptionHandler():
                        gen = ext(req=request, **action_args)
                        response = next(gen)
                except Fault as ex:
                    response = ex
                if response:
                    return (response, [])
                post.append(gen)
            else:
                post.append(ext)
        return (None, reversed(post))

    def post_process_extensions(self, extensions, resp_obj, request, action_args):
        for ext in extensions:
            response = None
            if inspect.isgenerator(ext):
                try:
                    with ResourceExceptionHandler():
                        response = ext.send(resp_obj)
                except StopIteration:
                    continue
                except Fault as ex:
                    response = ex
            else:
                try:
                    with ResourceExceptionHandler():
                        response = ext(req=request, resp_obj=resp_obj, **action_args)
                except exception.VersionNotFoundForAPIMethod:
                    continue
                except Fault as ex:
                    response = ex
            if response:
                return response
        return None

    @webob.dec.wsgify(RequestClass=Request)
    def __call__(self, request):
        'WSGI method that controls (de)serialization and method dispatch.'
        LOG.info('%(method)s %(url)s', {'method': request.method, 'url': request.url})
        if self.support_api_request_version:
            try:
                request.set_api_version_request(request.url)
            except exception.InvalidAPIVersionString as e:
                return Fault(webob.exc.HTTPBadRequest(explanation=six.text_type(e)))
            except exception.InvalidGlobalAPIVersion as e:
                return Fault(webob.exc.HTTPNotAcceptable(explanation=six.text_type(e)))
        action_args = self.get_action_args(request.environ)
        action = action_args.pop('action', None)
        (content_type, body) = self.get_body(request)
        accept = request.best_match_content_type()
        return self._process_stack(request, action, action_args, content_type, body, accept)

    def _process_stack(self, request, action, action_args, content_type, body, accept):
        'Implement the processing stack.'
        try:
            (meth, extensions) = self.get_method(request, action, content_type, body)
        except (AttributeError, TypeError):
            return Fault(webob.exc.HTTPNotFound())
        except KeyError as ex:
            msg = (_('There is no such action: %s') % ex.args[0])
            return Fault(webob.exc.HTTPBadRequest(explanation=msg))
        except exception.MalformedRequestBody:
            msg = _('Malformed request body')
            return Fault(webob.exc.HTTPBadRequest(explanation=msg))
        if body:
            decoded_body = encodeutils.safe_decode(body, errors='ignore')
            msg = ("Action: '%(action)s', calling method: %(meth)s, body: %(body)s" % {'action': action, 'body': six.text_type(decoded_body), 'meth': six.text_type(meth)})
            LOG.debug(strutils.mask_password(msg))
        else:
            LOG.debug("Calling method '%(meth)s'", {'meth': six.text_type(meth)})
        try:
            if content_type:
                contents = self.deserialize(meth, content_type, body)
            else:
                contents = {}
        except exception.InvalidContentType:
            msg = _('Unsupported Content-Type')
            return Fault(webob.exc.HTTPBadRequest(explanation=msg))
        except exception.MalformedRequestBody:
            msg = _('Malformed request body')
            return Fault(webob.exc.HTTPBadRequest(explanation=msg))
        action_args.update(contents)
        project_id = action_args.pop('project_id', None)
        context = request.environ.get('cinder.context')
        if (context and project_id and (project_id != context.project_id)):
            msg = _('Malformed request url')
            return Fault(webob.exc.HTTPBadRequest(explanation=msg))
        (response, post) = self.pre_process_extensions(extensions, request, action_args)
        if (not response):
            try:
                with ResourceExceptionHandler():
                    action_result = self.dispatch(meth, request, action_args)
            except Fault as ex:
                response = ex
        if (not response):
            resp_obj = None
            if (isinstance(action_result, dict) or (action_result is None)):
                resp_obj = ResponseObject(action_result)
            elif isinstance(action_result, ResponseObject):
                resp_obj = action_result
            else:
                response = action_result
            if resp_obj:
                _set_request_id_header(request, resp_obj)
                serializers = getattr(meth, 'wsgi_serializers', {})
                resp_obj._bind_method_serializers(serializers)
                if hasattr(meth, 'wsgi_code'):
                    resp_obj._default_code = meth.wsgi_code
                resp_obj.preserialize(accept, self.default_serializers)
                response = self.post_process_extensions(post, resp_obj, request, action_args)
            if (resp_obj and (not response)):
                response = resp_obj.serialize(request, accept, self.default_serializers)
        try:
            msg_dict = dict(url=request.url, status=response.status_int)
            msg = '%(url)s returned with HTTP %(status)d'
        except AttributeError as e:
            msg_dict = dict(url=request.url, e=e)
            msg = '%(url)s returned a fault: %(e)s'
        LOG.info(msg, msg_dict)
        if hasattr(response, 'headers'):
            for (hdr, val) in response.headers.items():
                val = utils.convert_str(val)
                response.headers[hdr] = val
            if (request.api_version_request and (not _is_legacy_endpoint(request))):
                response.headers[API_VERSION_REQUEST_HEADER] = ((VOLUME_SERVICE + ' ') + request.api_version_request.get_string())
                response.headers['Vary'] = API_VERSION_REQUEST_HEADER
        return response

    def get_method(self, request, action, content_type, body):
        'Look up the action-specific method and its extensions.'
        try:
            if (not self.controller):
                meth = getattr(self, action)
            else:
                meth = getattr(self.controller, action)
        except AttributeError as e:
            with excutils.save_and_reraise_exception(e) as ctxt:
                if ((not self.wsgi_actions) or (action not in ['action', 'create', 'delete', 'update'])):
                    LOG.exception('Get method error.')
                else:
                    ctxt.reraise = False
        else:
            return (meth, self.wsgi_extensions.get(action, []))
        if (action == 'action'):
            mtype = _MEDIA_TYPE_MAP.get(content_type)
            action_name = self.action_peek[mtype](body)
            LOG.debug('Action body: %s', body)
        else:
            action_name = action
        return (self.wsgi_actions[action_name], self.wsgi_action_extensions.get(action_name, []))

    def dispatch(self, method, request, action_args):
        'Dispatch a call to the action-specific method.'
        try:
            return method(req=request, **action_args)
        except exception.VersionNotFoundForAPIMethod:
            return Fault(webob.exc.HTTPNotFound())

def action(name):
    'Mark a function as an action.\n\n    The given name will be taken as the action key in the body.\n\n    This is also overloaded to allow extensions to provide\n    non-extending definitions of create and delete operations.\n    '

    def decorator(func):
        func.wsgi_action = name
        return func
    return decorator

def extends(*args, **kwargs):
    "Indicate a function extends an operation.\n\n    Can be used as either::\n\n        @extends\n        def index(...):\n            pass\n\n    or as::\n\n        @extends(action='resize')\n        def _action_resize(...):\n            pass\n    "

    def decorator(func):
        func.wsgi_extends = (func.__name__, kwargs.get('action'))
        return func
    if args:
        return decorator(*args)
    return decorator

class ControllerMetaclass(type, ):
    'Controller metaclass.\n\n    This metaclass automates the task of assembling a dictionary\n    mapping action keys to method names.\n    '

    def __new__(mcs, name, bases, cls_dict):
        'Adds the wsgi_actions dictionary to the class.'
        actions = {}
        extensions = []
        versioned_methods = []
        if ((bases != (object,)) and (VER_METHOD_ATTR in vars(Controller))):
            versioned_methods.append(getattr(Controller, VER_METHOD_ATTR))
            delattr(Controller, VER_METHOD_ATTR)
        for base in bases:
            actions.update(getattr(base, 'wsgi_actions', {}))
            if (VER_METHOD_ATTR in vars(base)):
                versioned_methods.append(getattr(base, VER_METHOD_ATTR))
        for (key, value) in cls_dict.items():
            if (not callable(value)):
                continue
            if getattr(value, 'wsgi_action', None):
                actions[value.wsgi_action] = key
            elif getattr(value, 'wsgi_extends', None):
                extensions.append(value.wsgi_extends)
        cls_dict['wsgi_actions'] = actions
        cls_dict['wsgi_extensions'] = extensions
        if versioned_methods:
            cls_dict[VER_METHOD_ATTR] = mcs.consolidate_vers(versioned_methods)
        return super(ControllerMetaclass, mcs).__new__(mcs, name, bases, cls_dict)

    @staticmethod
    def consolidate_vers(versioned_methods):
        'Consolidates a list of versioned methods dictionaries.'
        if (not versioned_methods):
            return {}
        result = versioned_methods.pop(0)
        for base_methods in versioned_methods:
            for (name, methods) in base_methods.items():
                method_list = result.setdefault(name, [])
                method_list.extend(methods)
                method_list.sort(reverse=True)
        return result

@six.add_metaclass(ControllerMetaclass)
class Controller(object, ):
    'Default controller.'
    _view_builder_class = None

    def __init__(self, view_builder=None):
        'Initialize controller with a view builder instance.'
        if view_builder:
            self._view_builder = view_builder
        elif self._view_builder_class:
            self._view_builder = self._view_builder_class()
        else:
            self._view_builder = None

    def __getattribute__(self, key):

        def version_select(*args, **kwargs):
            'Select and call the matching version of the specified method.\n\n            Look for the method which matches the name supplied and version\n            constraints and calls it with the supplied arguments.\n\n            :returns: Returns the result of the method called\n            :raises VersionNotFoundForAPIMethod: if there is no method which\n                 matches the name and version constraints\n            '
            if (len(args) == 0):
                version_request = kwargs['req'].api_version_request
            else:
                version_request = args[0].api_version_request
            func_list = self.versioned_methods[key]
            for func in func_list:
                if version_request.matches_versioned_method(func):
                    functools.update_wrapper(version_select, func.func)
                    return func.func(self, *args, **kwargs)
            raise exception.VersionNotFoundForAPIMethod(version=version_request)
        try:
            version_meth_dict = object.__getattribute__(self, VER_METHOD_ATTR)
        except AttributeError:
            return object.__getattribute__(self, key)
        if (version_meth_dict and (key in object.__getattribute__(self, VER_METHOD_ATTR))):
            return version_select
        return object.__getattribute__(self, key)

    @classmethod
    def api_version(cls, min_ver, max_ver=None, experimental=False):
        'Decorator for versioning API methods.\n\n        Add the decorator to any method which takes a request object\n        as the first parameter and belongs to a class which inherits from\n        wsgi.Controller.\n\n        :param min_ver: string representing minimum version\n        :param max_ver: optional string representing maximum version\n        '

        def decorator(f):
            obj_min_ver = api_version.APIVersionRequest(min_ver)
            if max_ver:
                obj_max_ver = api_version.APIVersionRequest(max_ver)
            else:
                obj_max_ver = api_version.APIVersionRequest()
            func_name = f.__name__
            new_func = versioned_method.VersionedMethod(func_name, obj_min_ver, obj_max_ver, experimental, f)
            func_dict = getattr(cls, VER_METHOD_ATTR, {})
            if (not func_dict):
                setattr(cls, VER_METHOD_ATTR, func_dict)
            func_list = func_dict.get(func_name, [])
            if (not func_list):
                func_dict[func_name] = func_list
            func_list.append(new_func)
            func_list.sort(reverse=True)
            f.api_version = cls.api_version
            return f
        return decorator

    @staticmethod
    def is_valid_body(body, entity_name):
        if (not (body and (entity_name in body))):
            return False

        def is_dict(d):
            try:
                d.get(None)
                return True
            except AttributeError:
                return False
        if (not is_dict(body[entity_name])):
            return False
        return True

    @staticmethod
    def assert_valid_body(body, entity_name):
        if (not Controller.is_valid_body(body, entity_name)):
            raise webob.exc.HTTPBadRequest(explanation=(_("Missing required element '%s' in request body.") % entity_name))

    @staticmethod
    def validate_name_and_description(body):
        for attribute in ['name', 'description', 'display_name', 'display_description']:
            value = body.get(attribute)
            if (value is not None):
                if isinstance(value, six.string_types):
                    body[attribute] = value.strip()
                try:
                    utils.check_string_length(body[attribute], attribute, min_length=0, max_length=255)
                except exception.InvalidInput as error:
                    raise webob.exc.HTTPBadRequest(explanation=error.msg)

    @staticmethod
    def validate_string_length(value, entity_name, min_length=0, max_length=None, remove_whitespaces=False):
        'Check the length of specified string.\n\n        :param value: the value of the string\n        :param entity_name: the name of the string\n        :param min_length: the min_length of the string\n        :param max_length: the max_length of the string\n        :param remove_whitespaces: True if trimming whitespaces is needed\n                                   else False\n        '
        if (isinstance(value, six.string_types) and remove_whitespaces):
            value = value.strip()
        try:
            utils.check_string_length(value, entity_name, min_length=min_length, max_length=max_length)
        except exception.InvalidInput as error:
            raise webob.exc.HTTPBadRequest(explanation=error.msg)

    @staticmethod
    def get_policy_checker(prefix):

        @staticmethod
        def policy_checker(req, action, resource=None):
            ctxt = req.environ['cinder.context']
            target = {'project_id': ctxt.project_id, 'user_id': ctxt.user_id}
            if resource:
                target.update(resource)
            _action = ('%s:%s' % (prefix, action))
            policy.enforce(ctxt, _action, target)
            return ctxt
        return policy_checker

class Fault(webob.exc.HTTPException, ):
    'Wrap webob.exc.HTTPException to provide API friendly response.'
    _fault_names = {http_client.BAD_REQUEST: 'badRequest', http_client.UNAUTHORIZED: 'unauthorized', http_client.FORBIDDEN: 'forbidden', http_client.NOT_FOUND: 'itemNotFound', http_client.METHOD_NOT_ALLOWED: 'badMethod', http_client.CONFLICT: 'conflictingRequest', http_client.REQUEST_ENTITY_TOO_LARGE: 'overLimit', http_client.UNSUPPORTED_MEDIA_TYPE: 'badMediaType', http_client.NOT_IMPLEMENTED: 'notImplemented', http_client.SERVICE_UNAVAILABLE: 'serviceUnavailable'}

    def __init__(self, exception):
        'Create a Fault for the given webob.exc.exception.'
        self.wrapped_exc = exception
        self.status_int = exception.status_int

    @webob.dec.wsgify(RequestClass=Request)
    def __call__(self, req):
        'Generate a WSGI response based on the exception passed to ctor.'
        locale = req.best_match_language()
        code = self.wrapped_exc.status_int
        fault_name = self._fault_names.get(code, 'computeFault')
        explanation = self.wrapped_exc.explanation
        fault_data = {fault_name: {'code': code, 'message': i18n.translate(explanation, locale)}}
        if (code == http_client.REQUEST_ENTITY_TOO_LARGE):
            retry = self.wrapped_exc.headers.get('Retry-After', None)
            if retry:
                fault_data[fault_name]['retryAfter'] = retry
        if (req.api_version_request and (not _is_legacy_endpoint(req))):
            self.wrapped_exc.headers[API_VERSION_REQUEST_HEADER] = ((VOLUME_SERVICE + ' ') + req.api_version_request.get_string())
            self.wrapped_exc.headers['Vary'] = API_VERSION_REQUEST_HEADER
        content_type = req.best_match_content_type()
        serializer = {'application/json': JSONDictSerializer()}[content_type]
        body = serializer.serialize(fault_data)
        if isinstance(body, six.text_type):
            body = body.encode('utf-8')
        self.wrapped_exc.body = body
        self.wrapped_exc.content_type = content_type
        _set_request_id_header(req, self.wrapped_exc.headers)
        return self.wrapped_exc

    def __str__(self):
        return self.wrapped_exc.__str__()

def _set_request_id_header(req, headers):
    context = req.environ.get('cinder.context')
    if context:
        headers['x-compute-request-id'] = context.request_id

def _is_legacy_endpoint(request):
    version_str = request.api_version_request.get_string()
    return (('1.0' in version_str) or ('2.0' in version_str))

class OverLimitFault(webob.exc.HTTPException, ):
    'Rate-limited request response.'

    def __init__(self, message, details, retry_time):
        'Initialize new `OverLimitFault` with relevant information.'
        hdrs = OverLimitFault._retry_after(retry_time)
        self.wrapped_exc = webob.exc.HTTPRequestEntityTooLarge(headers=hdrs)
        self.content = {'overLimitFault': {'code': self.wrapped_exc.status_int, 'message': message, 'details': details}}

    @staticmethod
    def _retry_after(retry_time):
        delay = int(math.ceil((retry_time - time.time())))
        retry_after = (delay if (delay > 0) else 0)
        headers = {'Retry-After': ('%d' % retry_after)}
        return headers

    @webob.dec.wsgify(RequestClass=Request)
    def __call__(self, request):
        'Serializes the wrapped exception conforming to our error format.'
        content_type = request.best_match_content_type()

        def translate(msg):
            locale = request.best_match_language()
            return i18n.translate(msg, locale)
        self.content['overLimitFault']['message'] = translate(self.content['overLimitFault']['message'])
        self.content['overLimitFault']['details'] = translate(self.content['overLimitFault']['details'])
        serializer = {'application/json': JSONDictSerializer()}[content_type]
        content = serializer.serialize(self.content)
        self.wrapped_exc.body = content
        return self.wrapped_exc
